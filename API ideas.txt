How will we store the list of files that have been uploaded in a way that is
extension ambiguous?
I think we should use a Map (String -> String) where the first string is a file
name and the second string is the actual id needed to access the file on the
cloud. 

This means that we can't have files with the same name and don't support any
kind of folder structure, but I think for a first implementation we should keep
it simple.

So the behaviour is something like:

Make an upload call to the API:
API checks for the file name in the map, if it's not there it uploads it as a
new file, if it is there it updates the old file. The API could return a
response whether the file was created or overwritten.

Make a delete call:
API checks for the file name in the map, and deletes it from the map
and the cloud storage. If the file isn't in the map it should throw.

Check if file exists and get metadata:
This is simple enough, just check if the file exists in the map, and if it does
return its metadata (fileName, fileSize, lastModified).

Make a download call:
API checks for the file name in the map, and downloads the file if it is found.
If the file isn't in the map it should throw.

We should have error checks in place to make sure the map and cloud storage
don't get out of sync, with appropriate error messages if it does. We can test
this by manually modifying the files outside of the extension.

The API should save the files to /Mozilla/Firefox/{extension-id}/, to prevent
cluttering the user's drive and keep extensions from interfering with each
other.

Ideally, interfacing with the API should be as simple as choosing a cloud
provider, calling an authenticate function, and then making calls. All token 
acquistion and refresh should be handled silently, where possible.

let remoteStore = createRemoteStorage("Google", clientId); // Initialises object
remoteStore.authenticate(); // Starts auth-flow

remoteStore.upload(fileName, object); // Upload an object as fileName
let file = remoteStore.get(fileName); // Download the fileName into file object
let info = remoteStore.getInfo(fileName); // Get info for fileName
let files = remoteStore.getInfo(); // Empty parameter should return all files info
remoteStore.delete(fileName); // Delete fileName

This will probably all have to be implemented with promises, I'm not sure
exactly how that works yet. I'm sure many problems will arise when trying to
implement this but this gives a starting point at least.